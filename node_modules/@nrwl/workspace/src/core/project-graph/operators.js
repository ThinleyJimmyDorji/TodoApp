"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.withDeps = exports.onlyWorkspaceProjects = exports.getSortedProjectNodes = exports.isNpmProject = exports.isWorkspaceProject = exports.filterNodes = exports.reverse = void 0;
const reverseMemo = new Map();
function reverse(graph) {
    const resultFromMemo = reverseMemo.get(graph);
    if (resultFromMemo)
        return resultFromMemo;
    const result = { nodes: graph.nodes, dependencies: {} };
    Object.keys(graph.nodes).forEach((n) => (result.dependencies[n] = []));
    Object.values(graph.dependencies).forEach((byProject) => {
        byProject.forEach((dep) => {
            result.dependencies[dep.target].push({
                type: dep.type,
                source: dep.target,
                target: dep.source,
            });
        });
    });
    reverseMemo.set(graph, result);
    reverseMemo.set(result, graph);
    return result;
}
exports.reverse = reverse;
function filterNodes(predicate) {
    return (original) => {
        const graph = { nodes: {}, dependencies: {} };
        const added = new Set();
        Object.values(original.nodes).forEach((n) => {
            if (predicate(n)) {
                graph.nodes[n.name] = n;
                graph.dependencies[n.name] = [];
                added.add(n.name);
            }
        });
        Object.values(original.dependencies).forEach((ds) => {
            ds.forEach((d) => {
                if (added.has(d.source) && added.has(d.target)) {
                    graph.dependencies[d.source].push(d);
                }
            });
        });
        return graph;
    };
}
exports.filterNodes = filterNodes;
function isWorkspaceProject(project) {
    return (project.type === 'app' || project.type === 'lib' || project.type === 'e2e');
}
exports.isWorkspaceProject = isWorkspaceProject;
function isNpmProject(project) {
    return project.type === 'npm';
}
exports.isNpmProject = isNpmProject;
function getSortedProjectNodes(nodes) {
    return Object.values(nodes).sort((nodeA, nodeB) => {
        // If a or b is not a nx project, leave them in the same spot
        if (!isWorkspaceProject(nodeA) && !isWorkspaceProject(nodeB)) {
            return 0;
        }
        // sort all non-projects lower
        if (!isWorkspaceProject(nodeA) && isWorkspaceProject(nodeB)) {
            return 1;
        }
        if (isWorkspaceProject(nodeA) && !isWorkspaceProject(nodeB)) {
            return -1;
        }
        return nodeA.data.root.length > nodeB.data.root.length ? -1 : 1;
    });
}
exports.getSortedProjectNodes = getSortedProjectNodes;
exports.onlyWorkspaceProjects = filterNodes(isWorkspaceProject);
function withDeps(original, subsetNodes) {
    const res = { nodes: {}, dependencies: {} };
    const visitedNodes = [];
    const visitedEdges = [];
    Object.values(subsetNodes).forEach(recurNodes);
    Object.values(subsetNodes).forEach(recurEdges);
    return res;
    // ---------------------------------------------------------------------------
    function recurNodes(node) {
        if (visitedNodes.indexOf(node.name) > -1)
            return;
        res.nodes[node.name] = node;
        if (!res.dependencies[node.name]) {
            res.dependencies[node.name] = [];
        }
        visitedNodes.push(node.name);
        original.dependencies[node.name].forEach((n) => {
            recurNodes(original.nodes[n.target]);
        });
    }
    function recurEdges(node) {
        if (visitedEdges.indexOf(node.name) > -1)
            return;
        visitedEdges.push(node.name);
        const ds = original.dependencies[node.name];
        ds.forEach((n) => {
            if (!res.dependencies[n.source]) {
                res.dependencies[n.source] = [];
            }
            res.dependencies[n.source].push(n);
        });
        ds.forEach((n) => {
            recurEdges(original.nodes[n.target]);
        });
    }
}
exports.withDeps = withDeps;
//# sourceMappingURL=operators.js.map