"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.readCurrentProjectGraph = exports.createProjectGraph = exports.createProjectGraphAsync = exports.readCachedProjectGraph = void 0;
const tslib_1 = require("tslib");
const devkit_1 = require("@nrwl/devkit");
const app_root_1 = require("@nrwl/tao/src/utils/app-root");
const path_1 = require("path");
const perf_hooks_1 = require("perf_hooks");
const assert_workspace_validity_1 = require("../assert-workspace-validity");
const file_graph_1 = require("../file-graph");
const file_utils_1 = require("../file-utils");
const normalize_nx_json_1 = require("../normalize-nx-json");
const nx_deps_cache_1 = require("../nx-deps/nx-deps-cache");
const build_dependencies_1 = require("./build-dependencies");
const build_nodes_1 = require("./build-nodes");
/**
 * Synchronously reads the latest cached copy of the workspace's ProjectGraph.
 * @throws {Error} if there is no cached ProjectGraph to read from
 */
function readCachedProjectGraph() {
    const projectGraphCache = nx_deps_cache_1.readCache();
    if (!projectGraphCache) {
        throw new Error(`
      [readCachedProjectGraph] ERROR: No cached ProjectGraph is available.
      
      If you are leveraging \`readCachedProjectGraph()\` directly then you will need to refactor your usage to first ensure that
      the ProjectGraph is created by calling \`await createProjectGraphAsync()\` somewhere before attempting to read the data.

      If you encounter this error as part of running standard \`nx\` commands then please open an issue on https://github.com/nrwl/nx
    `);
    }
    return {
        nodes: projectGraphCache.nodes,
        dependencies: projectGraphCache.dependencies,
    };
}
exports.readCachedProjectGraph = readCachedProjectGraph;
function createProjectGraphAsync() {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        return createProjectGraph();
    });
}
exports.createProjectGraphAsync = createProjectGraphAsync;
function readCombinedDeps() {
    const json = devkit_1.readJsonFile(path_1.join(app_root_1.appRootPath, 'package.json'));
    return Object.assign(Object.assign({}, json.dependencies), json.devDependencies);
}
// TODO(v13): remove this deprecated function
/**
 * @deprecated This function is deprecated in favor of the new asynchronous version {@link createProjectGraphAsync}
 */
function createProjectGraph(workspaceJson = file_utils_1.readWorkspaceJson(), nxJson = file_utils_1.readNxJson(), workspaceFiles = file_utils_1.readWorkspaceFiles()) {
    const cacheEnabled = process.env.NX_CACHE_PROJECT_GRAPH !== 'false';
    let cache = cacheEnabled ? nx_deps_cache_1.readCache() : false;
    assert_workspace_validity_1.assertWorkspaceValidity(workspaceJson, nxJson);
    const normalizedNxJson = normalize_nx_json_1.normalizeNxJson(nxJson);
    const projectFileMap = file_graph_1.createProjectFileMap(workspaceJson, workspaceFiles);
    const packageJsonDeps = readCombinedDeps();
    const rootTsConfig = readRootTsConfig();
    let filesToProcess = projectFileMap;
    let cachedFileData = {};
    if (cache &&
        cache.version === '3.0' &&
        !nx_deps_cache_1.shouldRecomputeWholeGraph(cache, packageJsonDeps, workspaceJson, normalizedNxJson, rootTsConfig) &&
        cacheEnabled) {
        const fromCache = nx_deps_cache_1.extractCachedFileData(projectFileMap, cache);
        filesToProcess = fromCache.filesToProcess;
        cachedFileData = fromCache.cachedFileData;
    }
    const context = createContext(workspaceJson, normalizedNxJson, projectFileMap, filesToProcess);
    const projectGraph = buildProjectGraph(context, cachedFileData);
    if (cacheEnabled) {
        nx_deps_cache_1.writeCache(packageJsonDeps, nxJson, rootTsConfig, projectGraph);
    }
    return addWorkspaceFiles(projectGraph, workspaceFiles);
}
exports.createProjectGraph = createProjectGraph;
// TODO(v13): remove this deprecated function
/**
 * @deprecated This function is deprecated in favor of {@link readCachedProjectGraph}
 */
function readCurrentProjectGraph() {
    const cache = nx_deps_cache_1.readCache();
    return cache === false ? null : cache;
}
exports.readCurrentProjectGraph = readCurrentProjectGraph;
function addWorkspaceFiles(projectGraph, allWorkspaceFiles) {
    return Object.assign(Object.assign({}, projectGraph), { allWorkspaceFiles });
}
function buildProjectGraph(ctx, cachedFileData) {
    perf_hooks_1.performance.mark('build project graph:start');
    const builder = new devkit_1.ProjectGraphBuilder();
    build_nodes_1.buildWorkspaceProjectNodes(ctx, builder);
    build_nodes_1.buildNpmPackageNodes(builder);
    for (const proj of Object.keys(cachedFileData)) {
        for (const f of builder.graph.nodes[proj].data.files) {
            const cached = cachedFileData[proj][f.file];
            if (cached) {
                f.deps = cached.deps;
            }
        }
    }
    build_dependencies_1.buildExplicitTypeScriptDependencies(ctx, builder);
    build_dependencies_1.buildExplicitPackageJsonDependencies(ctx, builder);
    build_dependencies_1.buildImplicitProjectDependencies(ctx, builder);
    const initProjectGraph = builder.getUpdatedProjectGraph();
    const r = updateProjectGraphWithPlugins(ctx, initProjectGraph);
    perf_hooks_1.performance.mark('build project graph:end');
    perf_hooks_1.performance.measure('build project graph', 'build project graph:start', 'build project graph:end');
    return r;
}
function createContext(workspaceJson, nxJson, fileMap, filesToProcess) {
    const projects = Object.keys(workspaceJson.projects).reduce((map, projectName) => {
        map[projectName] = Object.assign(Object.assign({}, workspaceJson.projects[projectName]), nxJson.projects[projectName]);
        return map;
    }, {});
    return {
        workspace: Object.assign(Object.assign(Object.assign({}, workspaceJson), nxJson), { projects }),
        fileMap,
        filesToProcess,
    };
}
function updateProjectGraphWithPlugins(context, initProjectGraph) {
    return (context.workspace.plugins || []).reduce((graph, path) => {
        try {
            const pluginPath = require.resolve(path, {
                paths: [app_root_1.appRootPath],
            });
            const pluginModule = require(pluginPath);
            if (!pluginModule.processProjectGraph) {
                return graph;
            }
            return pluginModule.processProjectGraph(graph, context);
        }
        catch (e) {
            const message = `Failed to process the project graph with "${path}". This will error in the future!`;
            if (process.env.NX_VERBOSE_LOGGING === 'true') {
                console.error(e);
                devkit_1.logger.error(message);
                return graph;
            }
            else {
                devkit_1.logger.warn(message);
                devkit_1.logger.warn(`Run with NX_VERBOSE_LOGGING=true to see the error.`);
            }
            return graph;
        }
    }, initProjectGraph);
}
function readRootTsConfig() {
    try {
        return devkit_1.readJsonFile(path_1.join(app_root_1.appRootPath, 'tsconfig.base.json'));
    }
    catch (e) {
        return devkit_1.readJsonFile(path_1.join(app_root_1.appRootPath, 'tsconfig.json'));
    }
}
//# sourceMappingURL=project-graph.js.map