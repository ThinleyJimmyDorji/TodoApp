"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.workspaceGenerators = void 0;
const tslib_1 = require("tslib");
const chalk = require("chalk");
const child_process_1 = require("child_process");
const fs_1 = require("fs");
const fs_extra_1 = require("fs-extra");
const path = require("path");
const yargsParser = require("yargs-parser");
const app_root_1 = require("@nrwl/tao/src/utils/app-root");
const fileutils_1 = require("../utilities/fileutils");
const output_1 = require("../utilities/output");
const workspace_1 = require("@nrwl/tao/src/shared/workspace");
const devkit_1 = require("@nrwl/devkit");
const generate_1 = require("@nrwl/tao/src/commands/generate");
const rootDirectory = app_root_1.appRootPath;
const toolsDir = path.join(rootDirectory, 'tools');
const generatorsDir = path.join(toolsDir, 'generators');
const toolsTsConfigPath = path.join(toolsDir, 'tsconfig.tools.json');
function workspaceGenerators(args) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const outDir = compileTools();
        const parsedArgs = parseOptions(args, outDir);
        const collectionFile = path.join(outDir, 'workspace-generators.json');
        if (parsedArgs.listGenerators) {
            return listGenerators(collectionFile);
        }
        const generatorName = args[0];
        const ws = new workspace_1.Workspaces(rootDirectory);
        args[0] = collectionFile + ':' + generatorName;
        if (ws.isNxGenerator(collectionFile, generatorName)) {
            process.exitCode = yield generate_1.generate(process.cwd(), rootDirectory, args, parsedArgs.verbose);
        }
        else {
            const logger = require('@angular-devkit/core/node').createConsoleLogger(parsedArgs.verbose, process.stdout, process.stderr);
            try {
                const workflow = createWorkflow(ws, parsedArgs.dryRun);
                yield executeAngularDevkitSchematic(generatorName, parsedArgs, workflow, outDir, logger);
            }
            catch (_a) {
                process.exit(1);
            }
        }
    });
}
exports.workspaceGenerators = workspaceGenerators;
// compile tools
function compileTools() {
    const toolsOutDir = getToolsOutDir();
    fs_extra_1.removeSync(toolsOutDir);
    compileToolsDir(toolsOutDir);
    const generatorsOutDir = path.join(toolsOutDir, 'generators');
    const collectionData = constructCollection();
    devkit_1.writeJsonFile(path.join(generatorsOutDir, 'workspace-generators.json'), collectionData);
    return generatorsOutDir;
}
function getToolsOutDir() {
    return path.resolve(toolsDir, toolsTsConfig().compilerOptions.outDir);
}
function compileToolsDir(outDir) {
    fs_extra_1.copySync(generatorsDir, path.join(outDir, 'generators'));
    const tmpTsConfigPath = createTmpTsConfig(toolsTsConfigPath, {
        include: [path.join(generatorsDir, '**/*.ts')],
    });
    const pmc = devkit_1.getPackageManagerCommand();
    const tsc = `${pmc.exec} tsc`;
    try {
        child_process_1.execSync(`${tsc} -p ${tmpTsConfigPath}`, {
            stdio: 'inherit',
            cwd: rootDirectory,
        });
    }
    catch (_a) {
        process.exit(1);
    }
}
function constructCollection() {
    const generators = {};
    fs_1.readdirSync(generatorsDir).forEach((c) => {
        const childDir = path.join(generatorsDir, c);
        if (fs_1.existsSync(path.join(childDir, 'schema.json'))) {
            generators[c] = {
                factory: `./${c}`,
                schema: `./${devkit_1.normalizePath(path.join(c, 'schema.json'))}`,
                description: `Schematic ${c}`,
            };
        }
    });
    return {
        name: 'workspace-generators',
        version: '1.0',
        generators,
        schematics: generators,
    };
}
function toolsTsConfig() {
    return devkit_1.readJsonFile(toolsTsConfigPath);
}
function createWorkflow(workspace, dryRun) {
    const { virtualFs, schema } = require('@angular-devkit/core');
    const { NodeJsSyncHost } = require('@angular-devkit/core/node');
    const { formats } = require('@angular-devkit/schematics');
    const { NodeWorkflow } = require('@angular-devkit/schematics/tools');
    const root = devkit_1.normalizePath(rootDirectory);
    const host = new virtualFs.ScopedHost(new NodeJsSyncHost(), root);
    const workflow = new NodeWorkflow(host, {
        packageManager: devkit_1.detectPackageManager(),
        dryRun,
        registry: new schema.CoreSchemaRegistry(formats.standardFormats),
        resolvePaths: [process.cwd(), rootDirectory],
    });
    workflow.registry.addSmartDefaultProvider('projectName', () => workspace.calculateDefaultProjectName(process.cwd(), workspace.readWorkspaceConfiguration()));
    return workflow;
}
function listGenerators(collectionFile) {
    try {
        const bodyLines = [];
        const collection = devkit_1.readJsonFile(collectionFile);
        bodyLines.push(chalk.bold(chalk.green('WORKSPACE GENERATORS')));
        bodyLines.push('');
        bodyLines.push(...Object.entries(collection.generators).map(([schematicName, schematicMeta]) => {
            return `${chalk.bold(schematicName)} : ${schematicMeta.description}`;
        }));
        bodyLines.push('');
        output_1.output.log({
            title: '',
            bodyLines,
        });
    }
    catch (error) {
        devkit_1.logger.fatal(error.message);
        return 1;
    }
    return 0;
}
function createPromptProvider() {
    return (definitions) => {
        const questions = definitions.map((definition) => {
            const question = {
                name: definition.id,
                message: definition.message,
            };
            if (definition.default) {
                question.initial = definition.default;
            }
            const validator = definition.validator;
            if (validator) {
                question.validate = (input) => validator(input);
            }
            switch (definition.type) {
                case 'string':
                case 'input':
                    return Object.assign(Object.assign({}, question), { type: 'input' });
                case 'boolean':
                case 'confirmation':
                case 'confirm':
                    return Object.assign(Object.assign({}, question), { type: 'confirm' });
                case 'number':
                case 'numeral':
                    return Object.assign(Object.assign({}, question), { type: 'numeral' });
                case 'list':
                    return Object.assign(Object.assign({}, question), { type: !!definition.multiselect ? 'multiselect' : 'select', choices: definition.items &&
                            definition.items.map((item) => {
                                if (typeof item == 'string') {
                                    return item;
                                }
                                else {
                                    return {
                                        message: item.label,
                                        name: item.value,
                                    };
                                }
                            }) });
                default:
                    return Object.assign(Object.assign({}, question), { type: definition.type });
            }
        });
        return require('enquirer').prompt(questions);
    };
}
// execute schematic
function executeAngularDevkitSchematic(schematicName, options, workflow, outDir, logger) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const { schema } = require('@angular-devkit/core');
        const { validateOptionsWithSchema, } = require('@angular-devkit/schematics/tools');
        const { UnsuccessfulWorkflowExecution, } = require('@angular-devkit/schematics');
        output_1.output.logSingleLine(`${output_1.output.colors.gray(`Executing your local schematic`)}: ${schematicName}`);
        let nothingDone = true;
        let loggingQueue = [];
        let hasError = false;
        workflow.reporter.subscribe((event) => {
            nothingDone = false;
            const eventPath = event.path.startsWith('/')
                ? event.path.substr(1)
                : event.path;
            switch (event.kind) {
                case 'error':
                    hasError = true;
                    const desc = event.description == 'alreadyExist'
                        ? 'already exists'
                        : 'does not exist.';
                    logger.warn(`ERROR! ${eventPath} ${desc}.`);
                    break;
                case 'update':
                    loggingQueue.push(`${chalk.white('UPDATE')} ${eventPath} (${event.content.length} bytes)`);
                    break;
                case 'create':
                    loggingQueue.push(`${chalk.green('CREATE')} ${eventPath} (${event.content.length} bytes)`);
                    break;
                case 'delete':
                    loggingQueue.push(`${chalk.yellow('DELETE')} ${eventPath}`);
                    break;
                case 'rename':
                    const eventToPath = event.to.startsWith('/')
                        ? event.to.substr(1)
                        : event.to;
                    loggingQueue.push(`${chalk.blue('RENAME')} ${eventPath} => ${eventToPath}`);
                    break;
            }
        });
        workflow.lifeCycle.subscribe((event) => {
            if (event.kind === 'workflow-end' || event.kind === 'post-tasks-start') {
                if (!hasError) {
                    loggingQueue.forEach((log) => logger.info(log));
                }
                loggingQueue = [];
                hasError = false;
            }
        });
        const args = options._.slice(1);
        workflow.registry.addSmartDefaultProvider('argv', (schema) => {
            if ('index' in schema) {
                return args[+schema.index];
            }
            else {
                return args;
            }
        });
        delete options._;
        if (options.defaults) {
            workflow.registry.addPreTransform(schema.transforms.addUndefinedDefaults);
        }
        else {
            workflow.registry.addPostTransform(schema.transforms.addUndefinedDefaults);
        }
        workflow.engineHost.registerOptionsTransform(validateOptionsWithSchema(workflow.registry));
        // Add support for interactive prompts
        if (options.interactive) {
            workflow.registry.usePromptProvider(createPromptProvider());
        }
        try {
            yield workflow
                .execute({
                collection: path.join(outDir, 'workspace-generators.json'),
                schematic: schematicName,
                options,
                logger,
            })
                .toPromise();
            if (nothingDone) {
                logger.info('Nothing to be done.');
            }
            if (options.dryRun) {
                logger.warn(`\nNOTE: The "dryRun" flag means no changes were made.`);
            }
        }
        catch (err) {
            if (err instanceof UnsuccessfulWorkflowExecution) {
                // "See above" because we already printed the error.
                logger.fatal('The Schematic workflow failed. See above.');
            }
            else {
                logger.fatal(err.stack || err.message);
            }
            throw err;
        }
    });
}
function parseOptions(args, outDir) {
    const schemaPath = path.join(outDir, args[0], 'schema.json');
    let booleanProps = [];
    if (fileutils_1.fileExists(schemaPath)) {
        const { properties } = devkit_1.readJsonFile(path.join(outDir, args[0], 'schema.json'));
        if (properties) {
            booleanProps = Object.keys(properties).filter((key) => properties[key].type === 'boolean');
        }
    }
    return yargsParser(args, {
        boolean: ['dryRun', 'listGenerators', 'interactive', ...booleanProps],
        alias: {
            dryRun: ['d'],
            listSchematics: ['l'],
        },
        default: {
            interactive: true,
        },
    });
}
function createTmpTsConfig(tsconfigPath, updateConfig) {
    const tmpTsConfigPath = path.join(path.dirname(tsconfigPath), 'tsconfig.generated.json');
    const originalTSConfig = devkit_1.readJsonFile(tsconfigPath);
    const generatedTSConfig = Object.assign(Object.assign({}, originalTSConfig), updateConfig);
    process.on('exit', () => cleanupTmpTsConfigFile(tmpTsConfigPath));
    devkit_1.writeJsonFile(tmpTsConfigPath, generatedTSConfig);
    return tmpTsConfigPath;
}
function cleanupTmpTsConfigFile(tmpTsConfigPath) {
    if (tmpTsConfigPath) {
        fs_extra_1.removeSync(tmpTsConfigPath);
    }
}
//# sourceMappingURL=workspace-generators.js.map