"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateGraph = void 0;
const tslib_1 = require("tslib");
const path_1 = require("@nrwl/devkit/src/utils/path");
const chokidar_1 = require("chokidar");
const crypto_1 = require("crypto");
const fs_1 = require("fs");
const fs_extra_1 = require("fs-extra");
const http = require("http");
const ignore_1 = require("ignore");
const open = require("open");
const path_2 = require("path");
const perf_hooks_1 = require("perf_hooks");
const url_1 = require("url");
const file_utils_1 = require("../core/file-utils");
const file_hasher_1 = require("../core/hasher/file-hasher");
const project_graph_1 = require("../core/project-graph");
const app_root_1 = require("@nrwl/tao/src/utils/app-root");
const cache_directory_1 = require("../utilities/cache-directory");
const fileutils_1 = require("../utilities/fileutils");
const output_1 = require("../utilities/output");
// maps file extention to MIME types
const mimeType = {
    '.ico': 'image/x-icon',
    '.html': 'text/html',
    '.js': 'text/javascript',
    '.json': 'application/json',
    '.css': 'text/css',
    '.png': 'image/png',
    '.jpg': 'image/jpeg',
    '.wav': 'audio/wav',
    '.mp3': 'audio/mpeg',
    '.svg': 'image/svg+xml',
    '.pdf': 'application/pdf',
    '.doc': 'application/msword',
    '.eot': 'appliaction/vnd.ms-fontobject',
    '.ttf': 'aplication/font-sfnt',
};
const nxDepsDir = cache_directory_1.cacheDirectory(app_root_1.appRootPath, cache_directory_1.readCacheDirectoryProperty(app_root_1.appRootPath));
function projectsToHtml(projects, graph, affected, focus, groupByFolder, exclude, layout, localMode, watchMode = false) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        let f = fs_1.readFileSync(path_2.join(__dirname, '../core/dep-graph/index.html'), 'utf-8');
        f = f
            .replace(`window.projects = []`, `window.projects = ${JSON.stringify(projects)}`)
            .replace(`window.graph = {}`, `window.graph = ${JSON.stringify(graph)}`)
            .replace(`window.affected = []`, `window.affected = ${JSON.stringify(affected)}`)
            .replace(`window.groupByFolder = false`, `window.groupByFolder = ${!!groupByFolder}`)
            .replace(`window.exclude = []`, `window.exclude = ${JSON.stringify(exclude)}`)
            .replace(`window.workspaceLayout = null`, `window.workspaceLayout = ${JSON.stringify(layout)}`);
        if (focus) {
            f = f.replace(`window.focusedProject = null`, `window.focusedProject = '${focus}'`);
        }
        if (watchMode) {
            f = f.replace(`window.watch = false`, `window.watch = true`);
        }
        if (localMode === 'build') {
            currentDepGraphClientResponse = yield createDepGraphClientResponse();
            f = f.replace(`window.projectGraphResponse = null`, `window.projectGraphResponse = ${JSON.stringify(currentDepGraphClientResponse)}`);
            f = f.replace(`window.localMode = 'serve'`, `window.localMode = 'build'`);
        }
        return f;
    });
}
function projectExists(projects, projectToFind) {
    return (projects.find((project) => project.name === projectToFind) !== undefined);
}
function hasPath(graph, target, node, visited) {
    if (target === node)
        return true;
    for (let d of graph.dependencies[node] || []) {
        if (visited.indexOf(d.target) > -1)
            continue;
        visited.push(d.target);
        if (hasPath(graph, target, d.target, visited))
            return true;
    }
    return false;
}
function filterGraph(graph, focus, exclude) {
    let projectNames = Object.values(graph.nodes).map((project) => project.name);
    let filteredProjectNames;
    if (focus !== null) {
        filteredProjectNames = new Set();
        projectNames.forEach((p) => {
            const isInPath = hasPath(graph, p, focus, []) || hasPath(graph, focus, p, []);
            if (isInPath) {
                filteredProjectNames.add(p);
            }
        });
    }
    else {
        filteredProjectNames = new Set(projectNames);
    }
    if (exclude.length !== 0) {
        exclude.forEach((p) => filteredProjectNames.delete(p));
    }
    let filteredGraph = {
        nodes: {},
        dependencies: {},
    };
    filteredProjectNames.forEach((p) => {
        filteredGraph.nodes[p] = graph.nodes[p];
        filteredGraph.dependencies[p] = graph.dependencies[p];
    });
    return filteredGraph;
}
function generateGraph(args, affectedProjects) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        let graph = project_graph_1.onlyWorkspaceProjects(yield project_graph_1.createProjectGraphAsync());
        const layout = file_utils_1.workspaceLayout();
        const projects = Object.values(graph.nodes);
        projects.sort((a, b) => {
            return a.name.localeCompare(b.name);
        });
        if (args.focus) {
            if (!projectExists(projects, args.focus)) {
                output_1.output.error({
                    title: `Project to focus does not exist.`,
                    bodyLines: [`You provided --focus=${args.focus}`],
                });
                process.exit(1);
            }
        }
        if (args.exclude) {
            const invalidExcludes = [];
            args.exclude.forEach((project) => {
                if (!projectExists(projects, project)) {
                    invalidExcludes.push(project);
                }
            });
            if (invalidExcludes.length > 0) {
                output_1.output.error({
                    title: `The following projects provided to --exclude do not exist:`,
                    bodyLines: invalidExcludes,
                });
                process.exit(1);
            }
        }
        let html;
        if (!args.file || args.file.endsWith('html')) {
            html = yield projectsToHtml(projects, graph, affectedProjects, args.focus || null, args.groupByFolder || false, args.exclude || [], layout, !!args.file && args.file.endsWith('html') ? 'build' : 'serve', args.watch);
        }
        else {
            graph = filterGraph(graph, args.focus || null, args.exclude || []);
        }
        if (args.file) {
            let folder = app_root_1.appRootPath;
            let filename = args.file;
            let ext = args.file.replace(/^.*\.(.*)$/, '$1');
            if (ext === 'html') {
                if (filename.includes('/')) {
                    const [_match, _folder, _file] = /^(.*)\/([^/]*\.(.*))$/.exec(args.file);
                    folder = `${app_root_1.appRootPath}/${_folder}`;
                    filename = _file;
                }
                filename = `${folder}/${filename}`;
                const assetsFolder = `${folder}/static`;
                const assets = [];
                fs_extra_1.copySync(path_2.join(__dirname, '../core/dep-graph'), assetsFolder, {
                    filter: (_src, dest) => {
                        const isntHtml = !/index\.html/.test(dest);
                        if (isntHtml && dest.includes('.')) {
                            assets.push(dest);
                        }
                        return isntHtml;
                    },
                });
                currentDepGraphClientResponse = yield createDepGraphClientResponse();
                html = html.replace(/src="/g, 'src="static/');
                html = html.replace(/href="styles/g, 'href="static/styles');
                html = html.replace('<base href="/">', '');
                html = html.replace(/type="module"/g, '');
                fs_1.writeFileSync(filename, html);
                output_1.output.success({
                    title: `HTML output created in ${folder}`,
                    bodyLines: [filename, ...assets],
                });
            }
            else if (ext === 'json') {
                filename = `${folder}/${filename}`;
                fs_extra_1.ensureDirSync(path_2.dirname(filename));
                fileutils_1.writeJsonFile(filename, {
                    graph,
                    affectedProjects,
                    criticalPath: affectedProjects,
                });
                output_1.output.success({
                    title: `JSON output created in ${folder}`,
                    bodyLines: [filename],
                });
            }
            else {
                output_1.output.error({
                    title: `Please specify a filename with either .json or .html extension.`,
                    bodyLines: [`You provided --file=${args.file}`],
                });
                process.exit(1);
            }
        }
        else {
            yield startServer(html, args.host || '127.0.0.1', args.port || 4211, args.watch, affectedProjects, args.focus, args.groupByFolder, args.exclude);
        }
    });
}
exports.generateGraph = generateGraph;
function startServer(html, host, port = 4211, watchForchanges = false, affected = [], focus = null, groupByFolder = false, exclude = []) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        if (watchForchanges) {
            startWatcher();
        }
        currentDepGraphClientResponse = yield createDepGraphClientResponse();
        currentDepGraphClientResponse.affected = affected;
        currentDepGraphClientResponse.focus = focus;
        currentDepGraphClientResponse.groupByFolder = groupByFolder;
        currentDepGraphClientResponse.exclude = exclude;
        const app = http.createServer((req, res) => {
            // parse URL
            const parsedUrl = new url_1.URL(req.url, `http://${host}:${port}`);
            // extract URL path
            // Avoid https://en.wikipedia.org/wiki/Directory_traversal_attack
            // e.g curl --path-as-is http://localhost:9000/../fileInDanger.txt
            // by limiting the path to current directory only
            const sanitizePath = path_2.basename(parsedUrl.pathname);
            if (sanitizePath === 'projectGraph.json') {
                res.writeHead(200, { 'Content-Type': 'application/json' });
                res.end(JSON.stringify(currentDepGraphClientResponse));
                return;
            }
            if (sanitizePath === 'currentHash') {
                res.writeHead(200, { 'Content-Type': 'application/json' });
                res.end(JSON.stringify({ hash: currentDepGraphClientResponse.hash }));
                return;
            }
            let pathname = path_2.join(__dirname, '../core/dep-graph/', sanitizePath);
            if (!fs_1.existsSync(pathname)) {
                // if the file is not found, return 404
                res.statusCode = 404;
                res.end(`File ${pathname} not found!`);
                return;
            }
            // if is a directory, then look for index.html
            if (fs_1.statSync(pathname).isDirectory()) {
                // pathname += '/index.html';
                res.writeHead(200, { 'Content-Type': 'text/html' });
                res.end(html);
                return;
            }
            try {
                const data = fs_1.readFileSync(pathname);
                const ext = path_2.parse(pathname).ext;
                res.setHeader('Content-type', mimeType[ext] || 'text/plain');
                res.end(data);
            }
            catch (err) {
                res.statusCode = 500;
                res.end(`Error getting the file: ${err}.`);
            }
        });
        app.listen(port, host);
        output_1.output.note({
            title: `Dep graph started at http://${host}:${port}`,
        });
        open(`http://${host}:${port}`);
    });
}
let currentDepGraphClientResponse = {
    hash: null,
    projects: [],
    dependencies: {},
    layout: {
        appsDir: '',
        libsDir: '',
    },
    changes: {
        added: [],
    },
    affected: [],
    focus: null,
    groupByFolder: false,
    exclude: [],
};
function getIgnoredGlobs(root) {
    const ig = ignore_1.default();
    try {
        ig.add(fs_1.readFileSync(`${root}/.gitignore`, 'utf-8'));
    }
    catch (_a) { }
    try {
        ig.add(fs_1.readFileSync(`${root}/.nxignore`, 'utf-8'));
    }
    catch (_b) { }
    return ig;
}
function startWatcher() {
    createFileWatcher(app_root_1.appRootPath, () => tslib_1.__awaiter(this, void 0, void 0, function* () {
        output_1.output.note({ title: 'Recalculating dependency graph...' });
        const newGraphClientResponse = yield createDepGraphClientResponse();
        if (newGraphClientResponse.hash !== currentDepGraphClientResponse.hash) {
            output_1.output.note({ title: 'Graph changes updated.' });
            currentDepGraphClientResponse = newGraphClientResponse;
        }
        else {
            output_1.output.note({ title: 'No graph changes found.' });
        }
    }));
}
function debounce(fn, time) {
    let timeout;
    return (...args) => {
        if (timeout) {
            clearTimeout(timeout);
        }
        timeout = setTimeout(() => fn(...args), time);
    };
}
function createFileWatcher(root, changeHandler) {
    const ignoredGlobs = getIgnoredGlobs(root);
    const layout = file_utils_1.workspaceLayout();
    const watcher = chokidar_1.watch([
        path_1.joinPathFragments(layout.appsDir, '**'),
        path_1.joinPathFragments(layout.libsDir, '**'),
    ], {
        cwd: root,
        ignoreInitial: true,
    });
    watcher.on('all', debounce((event, path) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        if (ignoredGlobs.ignores(path))
            return;
        yield changeHandler();
    }), 500));
    return { close: () => watcher.close() };
}
function createDepGraphClientResponse() {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        perf_hooks_1.performance.mark('dep graph watch calculation:start');
        file_hasher_1.defaultFileHasher.clear();
        file_hasher_1.defaultFileHasher.init();
        let graph = project_graph_1.onlyWorkspaceProjects(yield project_graph_1.createProjectGraphAsync());
        perf_hooks_1.performance.mark('dep graph watch calculation:end');
        perf_hooks_1.performance.mark('dep graph response generation:start');
        const layout = file_utils_1.workspaceLayout();
        const projects = Object.values(graph.nodes).map((project) => ({
            name: project.name,
            type: project.type,
            data: {
                tags: project.data.tags,
                root: project.data.root,
                files: [],
            },
        }));
        const dependencies = graph.dependencies;
        const hasher = crypto_1.createHash('sha256');
        hasher.update(JSON.stringify({ layout, projects, dependencies }));
        const hash = hasher.digest('hex');
        let added = [];
        if (currentDepGraphClientResponse.hash !== null &&
            hash !== currentDepGraphClientResponse.hash) {
            added = projects
                .filter((project) => {
                const result = currentDepGraphClientResponse.projects.find((previousProject) => previousProject.name === project.name);
                return !result;
            })
                .map((project) => project.name);
        }
        perf_hooks_1.performance.mark('dep graph response generation:end');
        perf_hooks_1.performance.measure('dep graph watch calculation', 'dep graph watch calculation:start', 'dep graph watch calculation:end');
        perf_hooks_1.performance.measure('dep graph response generation', 'dep graph response generation:start', 'dep graph response generation:end');
        return Object.assign(Object.assign({}, currentDepGraphClientResponse), { hash,
            layout,
            projects,
            dependencies, changes: {
                added: [...currentDepGraphClientResponse.changes.added, ...added],
            } });
    });
}
//# sourceMappingURL=dep-graph.js.map