"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.addRemoteToHost = void 0;
const devkit_1 = require("@nrwl/devkit");
const tsquery_1 = require("@phenomnomnominal/tsquery");
const ast_utils_1 = require("../../../utils/nx-devkit/ast-utils");
const ts = require("typescript");
function addRemoteToHost(host, options) {
    var _a, _b;
    if (options.mfeType === 'remote' && options.host) {
        const hostProject = devkit_1.readProjectConfiguration(host, options.host);
        const hostWebpackPath = (_a = hostProject.targets['build'].options.customWebpackConfig) === null || _a === void 0 ? void 0 : _a.path;
        if (!hostWebpackPath || !host.exists(hostWebpackPath)) {
            throw new Error(`The selected host application, ${options.host}, does not contain a webpack.config.js. Are you sure it has been set up as a host application?`);
        }
        const hostWebpackConfig = host.read(hostWebpackPath, 'utf-8');
        const webpackAst = tsquery_1.tsquery.ast(hostWebpackConfig);
        const mfRemotesNode = tsquery_1.tsquery(webpackAst, 'Identifier[name=remotes] ~ ObjectLiteralExpression', { visitAllChildren: true })[0];
        const endOfPropertiesPos = mfRemotesNode.properties.end;
        const updatedConfig = `${hostWebpackConfig.slice(0, endOfPropertiesPos)}
    \t\t"${options.appName}": '${options.appName}@http://localhost:${(_b = options.port) !== null && _b !== void 0 ? _b : 4200}/remoteEntry.js',${hostWebpackConfig.slice(endOfPropertiesPos)}`;
        host.write(hostWebpackPath, updatedConfig);
        const declarationFilePath = devkit_1.joinPathFragments(hostProject.sourceRoot, 'decl.d.ts');
        const declarationFileContent = (host.exists(declarationFilePath)
            ? host.read(declarationFilePath, 'utf-8')
            : '') + `\ndeclare module '${options.appName}/Module';`;
        host.write(declarationFilePath, declarationFileContent);
        addLazyLoadedRouteToHostAppModule(host, options);
    }
}
exports.addRemoteToHost = addRemoteToHost;
// TODO(colum): future work: allow dev to pass to path to routing module
function addLazyLoadedRouteToHostAppModule(host, options) {
    const hostAppConfig = devkit_1.readProjectConfiguration(host, options.host);
    const pathToHostAppModule = `${hostAppConfig.sourceRoot}/app/app.module.ts`;
    if (!host.exists(pathToHostAppModule)) {
        return;
    }
    const hostAppModule = host.read(pathToHostAppModule, 'utf-8');
    if (!hostAppModule.includes('RouterModule.forRoot(')) {
        return;
    }
    let sourceFile = ts.createSourceFile(pathToHostAppModule, hostAppModule, ts.ScriptTarget.Latest, true);
    sourceFile = ast_utils_1.addRoute(host, pathToHostAppModule, sourceFile, `{
         path: '${options.appName}', 
         loadChildren: () => import('${options.appName}/Module').then(m => m.RemoteEntryModule)
     }`);
}
//# sourceMappingURL=add-remote-to-host.js.map