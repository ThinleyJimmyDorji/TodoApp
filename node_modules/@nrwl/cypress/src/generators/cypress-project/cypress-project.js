"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.cypressProjectSchematic = exports.cypressProjectGenerator = exports.addLinter = void 0;
const tslib_1 = require("tslib");
const devkit_1 = require("@nrwl/devkit");
const linter_1 = require("@nrwl/linter");
const run_tasks_in_serial_1 = require("@nrwl/workspace/src/utilities/run-tasks-in-serial");
const path_1 = require("path");
const versions_1 = require("../../utils/versions");
const project_name_1 = require("../../utils/project-name");
function createFiles(host, options) {
    devkit_1.generateFiles(host, path_1.join(__dirname, './files'), options.projectRoot, Object.assign(Object.assign({ tmpl: '' }, options), { project: options.project || 'Project', ext: options.js ? 'js' : 'ts', offsetFromRoot: devkit_1.offsetFromRoot(options.projectRoot) }));
    if (options.js) {
        devkit_1.toJS(host);
    }
}
function addProject(tree, options) {
    let devServerTarget = `${options.project}:serve`;
    if (options.project) {
        const project = devkit_1.readProjectConfiguration(tree, options.project);
        devServerTarget =
            project.targets.serve && project.targets.serve.defaultConfiguration
                ? `${options.project}:serve:${project.targets.serve.defaultConfiguration}`
                : devServerTarget;
    }
    devkit_1.addProjectConfiguration(tree, options.projectName, {
        root: options.projectRoot,
        sourceRoot: devkit_1.joinPathFragments(options.projectRoot, 'src'),
        projectType: 'application',
        targets: {
            e2e: {
                executor: '@nrwl/cypress:cypress',
                options: {
                    cypressConfig: devkit_1.joinPathFragments(options.projectRoot, 'cypress.json'),
                    tsConfig: devkit_1.joinPathFragments(options.projectRoot, 'tsconfig.e2e.json'),
                    devServerTarget,
                },
                configurations: {
                    production: {
                        devServerTarget: `${options.project}:serve:production`,
                    },
                },
            },
        },
        tags: [],
        implicitDependencies: options.project ? [options.project] : undefined,
    }, options.standaloneConfig);
}
function addLinter(host, options) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        if (options.linter === linter_1.Linter.None) {
            return () => { };
        }
        const installTask = yield linter_1.lintProjectGenerator(host, {
            project: options.projectName,
            linter: options.linter,
            skipFormat: true,
            tsConfigPaths: [
                devkit_1.joinPathFragments(options.projectRoot, 'tsconfig.e2e.json'),
            ],
            eslintFilePatterns: [
                `${options.projectRoot}/**/*.${options.js ? 'js' : '{js,ts}'}`,
            ],
            setParserOptionsProject: options.setParserOptionsProject,
        });
        if (!options.linter || options.linter !== linter_1.Linter.EsLint) {
            return installTask;
        }
        const installTask2 = devkit_1.addDependenciesToPackageJson(host, {}, { 'eslint-plugin-cypress': versions_1.eslintPluginCypressVersion });
        devkit_1.updateJson(host, path_1.join(options.projectRoot, '.eslintrc.json'), (json) => {
            json.extends = ['plugin:cypress/recommended', ...json.extends];
            json.overrides = [
                /**
                 * In order to ensure maximum efficiency when typescript-eslint generates TypeScript Programs
                 * behind the scenes during lint runs, we need to make sure the project is configured to use its
                 * own specific tsconfigs, and not fall back to the ones in the root of the workspace.
                 */
                {
                    files: ['*.ts', '*.tsx', '*.js', '*.jsx'],
                    /**
                     * NOTE: We no longer set parserOptions.project by default when creating new projects.
                     *
                     * We have observed that users rarely add rules requiring type-checking to their Nx workspaces, and therefore
                     * do not actually need the capabilites which parserOptions.project provides. When specifying parserOptions.project,
                     * typescript-eslint needs to create full TypeScript Programs for you. When omitting it, it can perform a simple
                     * parse (and AST tranformation) of the source files it encounters during a lint run, which is much faster and much
                     * less memory intensive.
                     *
                     * In the rare case that users attempt to add rules requiring type-checking to their setup later on (and haven't set
                     * parserOptions.project), the executor will attempt to look for the particular error typescript-eslint gives you
                     * and provide feedback to the user.
                     */
                    parserOptions: !options.setParserOptionsProject
                        ? undefined
                        : {
                            project: `${options.projectRoot}/tsconfig.*?.json`,
                        },
                    /**
                     * Having an empty rules object present makes it more obvious to the user where they would
                     * extend things from if they needed to
                     */
                    rules: {},
                },
                /**
                 * We need this override because we enabled allowJS in the tsconfig to allow for JS based Cypress tests.
                 * That however leads to issues with the CommonJS Cypress plugin file.
                 */
                {
                    files: ['src/plugins/index.js'],
                    rules: {
                        '@typescript-eslint/no-var-requires': 'off',
                        'no-undef': 'off',
                    },
                },
            ];
            return json;
        });
        return run_tasks_in_serial_1.runTasksInSerial(installTask, installTask2);
    });
}
exports.addLinter = addLinter;
function cypressProjectGenerator(host, schema) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const options = normalizeOptions(host, schema);
        createFiles(host, options);
        addProject(host, options);
        const installTask = yield addLinter(host, options);
        if (!options.skipFormat) {
            yield devkit_1.formatFiles(host);
        }
        return installTask;
    });
}
exports.cypressProjectGenerator = cypressProjectGenerator;
function normalizeOptions(host, options) {
    const { appsDir } = devkit_1.getWorkspaceLayout(host);
    const projectName = options.directory
        ? `${project_name_1.filePathPrefix(options.directory)}-${options.name}`
        : options.name;
    const projectRoot = options.directory
        ? devkit_1.joinPathFragments(appsDir, devkit_1.names(options.directory).fileName, options.name)
        : devkit_1.joinPathFragments(appsDir, options.name);
    options.linter = options.linter || linter_1.Linter.EsLint;
    return Object.assign(Object.assign({}, options), { projectName,
        projectRoot });
}
exports.default = cypressProjectGenerator;
exports.cypressProjectSchematic = devkit_1.convertNxGenerator(cypressProjectGenerator);
//# sourceMappingURL=cypress-project.js.map