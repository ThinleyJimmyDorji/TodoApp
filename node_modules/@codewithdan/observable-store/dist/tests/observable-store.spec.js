Object.defineProperty(exports, "__esModule", { value: true });
var operators_1 = require("rxjs/operators");
var observable_store_1 = require("../observable-store");
var mocks_1 = require("./mocks");
var mockStore = null;
var userStore = null;
beforeEach(function () {
    observable_store_1.ObservableStore['isTesting'] = true;
    mockStore = new mocks_1.MockStore({ trackStateHistory: true });
    userStore = new mocks_1.UserStore(null);
    // Clear all existing store state
    observable_store_1.ObservableStore.clearState(null);
});
describe('Observable Store', function () {
    describe('Changing state', function () {
        it('should change a single property', function () {
            mockStore.updateProp1('test');
            expect(mockStore.currentState.prop1).toEqual('test');
        });
        it('should reset the store state', function () {
            var newState = { prop1: 'reset prop1 state', prop2: null, user: { name: 'reset user state' }, users: null };
            mockStore.updateProp1('test');
            observable_store_1.ObservableStore.resetState(newState);
            expect(mockStore.currentState.prop1).toEqual('reset prop1 state');
            expect(mockStore.currentState.user.name).toEqual('reset user state');
            expect(userStore.currentState.prop1).toEqual('reset prop1 state');
            expect(userStore.currentState.user.name).toEqual('reset user state');
        });
        it('should clear the store state', function () {
            var newState = { prop1: 'reset prop1 state', prop2: null, user: 'reset user state', users: null };
            mockStore.updateProp1('test');
            observable_store_1.ObservableStore.resetState(newState);
            observable_store_1.ObservableStore.clearState();
            expect(mockStore.currentState).toBeNull();
            expect(userStore.currentState).toBeNull();
        });
        it('should execute an anonymous function', function () {
            var capitalizeProp1 = function (state) {
                state.prop1 = state.prop1.toLocaleUpperCase();
                return state;
            };
            var capitalizeSpy = jasmine.createSpy().and.callFake(capitalizeProp1);
            mockStore.updateProp1('test');
            mockStore.updateUsingAFunction(capitalizeSpy);
            expect(capitalizeSpy).toHaveBeenCalled();
            expect(mockStore.currentState.prop1).toEqual('TEST');
        });
        it('should execute an anonymous function on a slice of data', function () {
            var updateUser = function (state) {
                if (!state) {
                    state = { prop1: null, prop2: null, user: null, users: null };
                }
                state.user = { name: 'fred' };
                return { user: state.user };
            };
            var updateUserSpy = jasmine.createSpy().and.callFake(updateUser);
            mockStore.updateUsingAFunction(updateUserSpy);
            expect(updateUserSpy).toHaveBeenCalled();
            expect(mockStore.currentState.user.name).toEqual('fred');
        });
    });
    describe('Subscriptions', function () {
        // we will skip 1 to account for the initial BehaviorSubject<T> value
        it('should NOT receive notification if no state has changed', function () {
            var receiveUpdate = false;
            var sub = mockStore.stateChanged.pipe(operators_1.skip(1)).subscribe(function () { return (receiveUpdate = true); });
            expect(receiveUpdate).toBeFalsy();
            sub.unsubscribe();
        });
        // we will skip 1 to account for the initial BehaviorSubject<T> value
        it('should receive notification when state has been changed', function () {
            var receiveUpdate = false;
            var sub = mockStore.stateChanged.pipe(operators_1.skip(1)).subscribe(function () { return (receiveUpdate = true); });
            mockStore.updateProp1('test');
            expect(receiveUpdate).toBeTruthy();
            sub.unsubscribe();
        });
        // we will skip 1 to account for the initial BehaviorSubject<T> value
        it('should receive notification when state has been reset', function () {
            var receivedUpdate = false;
            var receivedState = null;
            var sub = mockStore.stateChanged.pipe(operators_1.skip(1)).subscribe(function (state) {
                receivedUpdate = true;
                receivedState = state;
            });
            mockStore.updateProp1('initial state');
            observable_store_1.ObservableStore.resetState({ prop1: 'state reset', prop2: null, user: null, users: null });
            expect(receivedUpdate).toBeTruthy();
            expect(receivedState.prop1).toEqual('state reset');
            expect(receivedState.prop2).toBe(null);
            sub.unsubscribe();
        });
        // deprecated
        // we will skip 1 to account for the initial BehaviorSubject<T> value
        it('should receive state notification when includeStateChangesOnSubscribe set [deprecated]', function () {
            var mockStore = new mocks_1.MockStore({ includeStateChangesOnSubscribe: true });
            var receivedData;
            var sub = mockStore.stateChanged.pipe(operators_1.skip(1)).subscribe(function (stateWithChanges) { return receivedData = stateWithChanges; });
            mockStore.updateProp1('test');
            expect(receivedData.state.prop1).toEqual('test');
            expect(receivedData.stateChanges.prop1).toEqual('test');
            sub.unsubscribe();
        });
        // we will skip 1 to account for the initial BehaviorSubject<T> value
        it('should receive notification from stateChangedWithChanges', function () {
            var mockStore = new mocks_1.MockStore({});
            var receivedData;
            var sub = mockStore.stateWithPropertyChanges.pipe(operators_1.skip(1)).subscribe(function (stateWithChanges) {
                receivedData = stateWithChanges;
            });
            mockStore.updateProp1('test');
            expect(receivedData.state.prop1).toEqual('test');
            expect(receivedData.stateChanges.prop1).toEqual('test');
            sub.unsubscribe();
        });
        // we will skip 1 to account for the initial BehaviorSubject<T> value
        it('should receive notification from globalStateChanged', function () {
            var mockStore = new mocks_1.MockStore({});
            var receivedData = [];
            var sub = mockStore.globalStateChanged.pipe(operators_1.skip(1)).subscribe(function (state) {
                receivedData.push(state);
            });
            mockStore.updateProp1('test');
            expect(receivedData.length).toEqual(1);
            expect(receivedData[0].prop1).toEqual('test');
            sub.unsubscribe();
        });
        // we will skip 1 to account for the initial BehaviorSubject<T> value
        it('should receive notification from globalStateChangedWithChanges', function () {
            var mockStore = new mocks_1.MockStore({});
            var receivedData;
            var sub = mockStore.globalStateWithPropertyChanges.pipe(operators_1.skip(1)).subscribe(function (stateWithChanges) {
                receivedData = stateWithChanges;
            });
            mockStore.updateProp1('test');
            expect(receivedData.state.prop1).toEqual('test');
            expect(receivedData.stateChanges.prop1).toEqual('test');
            sub.unsubscribe();
        });
    });
    describe('Action', function () {
        it('should add valid action to stateHistory', function () {
            var mockAction = 'Mock_Action';
            mockStore.updateForTestAction('test', mockAction);
            expect(mockStore.stateHistory[mockStore.stateHistory.length - 1].action).toEqual(mockAction);
        });
    });
    describe('getStateProperty', function () {
        it('should retrieve single user property when string property name passed', function () {
            userStore.setState({ user: mocks_1.getUser() });
            expect(userStore.currentState.user).toBeTruthy();
            var state = userStore.getStateProperty('user');
            expect(state.name).toBeTruthy();
            expect(state.users).toBeUndefined();
        });
    });
    describe('SliceSelector', function () {
        it('should only have MockUser when requesting state', function () {
            userStore = new mocks_1.UserStore({
                stateSliceSelector: function (state) {
                    if (state) {
                        return { user: state.user };
                    }
                }
            });
            userStore.updateUser({ name: 'foo', address: { city: 'Phoenix', state: 'AZ', zip: 85349 } });
            var state = userStore.currentState;
            expect(state.prop1).toBeFalsy();
            expect(state.prop2).toBeFalsy();
            // although the state is populated, slice will only populate the User
            expect(state.user).toBeTruthy();
        });
    });
    describe('Cloning', function () {
        var user = null;
        beforeEach(function () {
            user = mocks_1.getUser();
        });
        it('should clone Map object added to store', function () {
            var map = new Map();
            map.set('key1', 22);
            map.set('key2', 32);
            userStore.updateMap(map);
            var state = userStore.getCurrentState();
            expect(map).toBe(map);
            expect(state.map).not.toBe(map);
            expect(state.map.size).toEqual(map.size);
        });
        it('should deep clone when setState called', function () {
            userStore.updateUser(user);
            user.address.city = 'Las Vegas';
            expect(userStore.currentState.user.address.city).not.toEqual('Las Vegas');
        });
        it('should NOT deep clone when setState called', function () {
            userStore.updateUser(user, false); // don't clone when setting state
            user.address.city = 'Las Vegas';
            expect(userStore.currentState.user.address.city).toEqual('Las Vegas');
        });
        it('should NOT deep clone when setState or getState called', function () {
            // Set state but don't clone
            userStore.updateUser(user, false);
            // Get state but don't clone
            var nonClonedUserState = userStore.getCurrentState(false);
            // Update user which should also update store
            nonClonedUserState.user.address.city = 'Las Vegas';
            // Ensure user was updated by reference
            expect(userStore.currentState.user.address.city).toEqual('Las Vegas');
        });
        it('should deep clone when setState or getState called', function () {
            // Set state but don't clone
            userStore.updateUser(user);
            var clonedUserState = userStore.getCurrentState();
            clonedUserState.user.address.city = 'Las Vegas';
            expect(userStore.currentState.user.address.city).not.toEqual('Las Vegas');
        });
        it('should deep clone array', function () {
            userStore.addToUsers(user);
            var users = userStore.getCurrentState().users;
            // Should NOT affect store users array since it would be cloned
            users.push({ name: 'user2', address: { city: 'Chandler', state: 'AZ', zip: 85249 } });
            expect(users.length).toEqual(2);
            expect(userStore.currentState.users.length).toEqual(1);
        });
        it('should NOT deep clone array', function () {
            userStore.addToUsers(user, false);
            var users = userStore.getCurrentState(false).users;
            users.push({ name: 'user2', address: { city: 'Chandler', state: 'AZ', zip: 85249 } });
            expect(userStore.currentState.users.length).toEqual(2);
        });
        it('should deep clone with matching number of keys', function () {
            userStore.updateUser(user);
            userStore.addToUsers(user);
            var stateKeys = Object.getOwnPropertyNames(userStore.currentState);
            expect(stateKeys.length).toEqual(2);
        });
        it('should NOT deep clone but have matching number of keys', function () {
            userStore.updateUser(user, false);
            userStore.addToUsers(user, false);
            var stateKeys = Object.getOwnPropertyNames(userStore.currentState);
            expect(stateKeys.length).toEqual(2);
        });
    });
    describe('globalSettings', function () {
        it('should store global settings', function () {
            observable_store_1.ObservableStore.globalSettings = { trackStateHistory: true };
            var settingsKeys = Object.getOwnPropertyNames(observable_store_1.ObservableStore.globalSettings);
            expect(settingsKeys.length).toEqual(1);
        });
        it('should error when no global settings passed', function () {
            try {
                observable_store_1.ObservableStore.globalSettings = null;
            }
            catch (e) {
                expect(e.message).toEqual('Please provide the global settings you would like to apply to Observable Store');
            }
        });
        it('should set initial state', function () {
            observable_store_1.ObservableStore.initializeState({ user: { name: 'Fred' } });
            var state = userStore.currentState;
            expect(state.user.name).toEqual('Fred');
        });
        it('should error when setting initial state and state already exists', function () {
            // Update store state
            mockStore.updateProp1();
            try {
                // Try to initialize state (should throw)
                observable_store_1.ObservableStore.initializeState({ user: { name: 'Fred' } });
            }
            catch (e) {
                expect(e.message).toEqual('The store state has already been initialized. initializeStoreState() can ' +
                    'only be called once BEFORE any store state has been set.');
            }
        });
        it('should error when global settings passed more than once', function () {
            observable_store_1.ObservableStore.globalSettings = { trackStateHistory: true };
            try {
                observable_store_1.ObservableStore.globalSettings = { trackStateHistory: false };
            }
            catch (e) {
                expect(e.message).toEqual('Observable Store global settings may only be set once.');
            }
        });
    });
    describe('trackHistory', function () {
        var user = null;
        beforeEach(function () {
            user = mocks_1.getUser();
        });
        it('should set trackHistory through global settings', function () {
            observable_store_1.ObservableStore.globalSettings = { trackStateHistory: true };
            userStore = new mocks_1.UserStore(null);
            userStore.updateUser(user);
            userStore.updateUser(user);
            expect(userStore.stateHistory.length).toEqual(2);
        });
        it('should turn off trackHistory through global settings', function () {
            observable_store_1.ObservableStore.globalSettings = { trackStateHistory: false };
            userStore = new mocks_1.UserStore(null);
            userStore.updateUser(user);
            userStore.updateUser(user);
            expect(userStore.stateHistory.length).toEqual(0);
        });
        it('should turn on trackHistory through settings', function () {
            observable_store_1.ObservableStore.globalSettings = {};
            userStore = new mocks_1.UserStore({ trackStateHistory: true });
            userStore.updateUser(user);
            userStore.updateUser(user);
            expect(userStore.stateHistory.length).toEqual(2);
        });
        it('should turn off trackHistory through settings', function () {
            observable_store_1.ObservableStore.globalSettings = {};
            userStore = new mocks_1.UserStore({ trackStateHistory: false });
            userStore.updateUser(user);
            expect(userStore.stateHistory.length).toEqual(0);
        });
    });
});
//# sourceMappingURL=observable-store.spec.js.map