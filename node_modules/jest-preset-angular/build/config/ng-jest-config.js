"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NgJestConfig = void 0;
const file_system_1 = require("@angular/compiler-cli/src/ngtsc/file_system");
const perform_compile_1 = require("@angular/compiler-cli/src/perform_compile");
const config_set_1 = require("ts-jest/dist/config/config-set");
class NgJestConfig extends config_set_1.ConfigSet {
    constructor(jestCfg) {
        super(jestCfg);
        this.jestCfg = jestCfg;
    }
    _resolveTsConfig(compilerOptions, resolvedConfigFile) {
        var _a, _b;
        file_system_1.setFileSystem(new file_system_1.NodeJSFileSystem());
        this.logger.debug('_resolveTsConfig: read and resolve config from tsconfig using @angular/compiler-cli readConfiguration');
        let result;
        if (resolvedConfigFile) {
            result = perform_compile_1.readConfiguration(resolvedConfigFile);
        }
        else {
            result = perform_compile_1.readConfiguration(this.cwd);
            if (compilerOptions) {
                result = Object.assign(Object.assign({}, result), { options: Object.assign(Object.assign({}, result.options), compilerOptions) });
            }
        }
        if ((_a = result.errors) === null || _a === void 0 ? void 0 : _a.length) {
            throw new Error(perform_compile_1.formatDiagnostics(result.errors));
        }
        return Object.assign(Object.assign({}, result), { fileNames: result.rootNames, options: Object.assign(Object.assign({}, result.options), { suppressOutputPathCheck: true, skipLibCheck: (_b = result.options.skipLibCheck) !== null && _b !== void 0 ? _b : true, annotationsAs: 'decorators' }) });
    }
}
exports.NgJestConfig = NgJestConfig;
